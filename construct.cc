#include "combination.h"

#include <deque>
#include <iostream>
#include <set>
#include <string>
#include <utility>

#include "absl/strings/str_cat.h"

class RelationshipCacheWithQueue {
 public:
  using CombinationPair = std::pair<std::string, std::string>;

  void Insert(CombinationPair element) {
    std::set<CombinationPair>::iterator it =
        related_cache_.lower_bound(element);
    if (it != related_cache_.end() && *it == element) {
      return;
    }

    related_cache_.insert(it, element);
    related_deque_.push_back(element);
  }

  CombinationPair Dequeue() {
    CombinationPair front = std::move(related_deque_.front());
    related_deque_.pop_front();
    return front;
  }
  bool DequeEmpty() const { return related_deque_.empty(); }

  const std::set<CombinationPair>& RelatedPairs() const {
    return related_cache_;
  }

 private:
  // Pairs of combinations that are known to be specially related.
  std::set<CombinationPair> related_cache_;

  // Pairs of combinations that have already been inserted into `related_cache_`
  // but other pairs generated by them have not.
  std::deque<CombinationPair> related_deque_;
};

int main() {
  const int kMaxLength = 10;
  RelationshipCacheWithQueue r;

  // Seed known related pairs using Q property
  for (int length = 1; length <= kMaxLength - 2; length++) {
    std::string combination = first_combination(length);
    do {
      r.Insert({combination, absl::StrCat("Q", combination, "Q")});
    } while (next_combination(combination));
  }

  while (!r.DequeEmpty()) {
    RelationshipCacheWithQueue::CombinationPair pair = r.Dequeue();
    const std::string& first = pair.first;
    const std::string& second = pair.second;

    if (first.length() == kMaxLength) {
      continue;
    }

    // V property
    // TODO reverse `second`
    r.Insert({absl::StrCat("V", first), second});

    if (second.length() == kMaxLength) {
      continue;
    }

    // L property
    r.Insert({absl::StrCat("L", first), absl::StrCat("Q", second)});

    if (2 * second.length() > kMaxLength) {
      continue;
    }

    // R property
    r.Insert({absl::StrCat("R", first), absl::StrCat(second, second)});
  }

  const std::set<RelationshipCacheWithQueue::CombinationPair>& related_pairs =
      r.RelatedPairs();
  for (const RelationshipCacheWithQueue::CombinationPair& pair :
       related_pairs) {
    if (pair.first == pair.second) {
      std::cout << pair.first << std::endl;
    }
  }

  return 0;
}
