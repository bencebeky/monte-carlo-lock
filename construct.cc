#include "combination.h"

#include <deque>
#include <iostream>
#include <set>
#include <string>
#include <utility>

class RelationshipCacheWithQueue {
 public:
  using CombinationPair = std::pair<std::string, std::string>;

  void Insert(CombinationPair element) {
    std::set<CombinationPair>::iterator it =
        related_cache_.lower_bound(element);
    if (it != related_cache_.end() && *it == element) {
      return;
    }

    related_cache_.insert(it, element);
    related_deque_.push_back(element);
  }

  CombinationPair Dequeue() {
    CombinationPair front = std::move(related_deque_.front());
    related_deque_.pop_front();
    return front;
  }
  bool DequeEmpty() const { return related_deque_.empty(); }

  const std::set<CombinationPair>& RelatedPairs() const {
    return related_cache_;
  }

 private:
  // Pairs of combinations that are known to be specially related.
  std::set<CombinationPair> related_cache_;

  // Pairs of combinations that have already been inserted into `related_cache_`
  // but other pairs generated by them have not.
  std::deque<CombinationPair> related_deque_;
};

int main() {
  const int kMaxLength = 10;
  RelationshipCacheWithQueue r;

  // Seed known related pairs using Q property
  for (int length = 1; length <= kMaxLength - 2; length++) {
    std::string combination = first_combination(length);
    do {
      std::string q;
      q.push_back('Q');
      q.append(combination);
      q.push_back('Q');
      r.Insert({combination, q});
    } while (next_combination(combination));
  }

  while (!r.DequeEmpty()) {
    RelationshipCacheWithQueue::CombinationPair pair = r.Dequeue();
    const std::string& first = pair.first;
    const std::string& second = pair.second;

    if (first.length() == kMaxLength) {
      continue;
    }

    // V property
    std::string v("V");
    v.append(first);
    r.Insert({v, second});

    if (second.length() == kMaxLength) {
      continue;
    }

    // L property
    std::string l_first("L");
    l_first.append(first);
    std::string l_second("Q");
    l_second.append(second);
    r.Insert({l_first, l_second});

    if (2 * second.length() > kMaxLength) {
      continue;
    }

    // R property
    std::string r_first("R");
    r_first.append(first);
    std::string r_second(second);
    r_second.append(second);
    r.Insert({r_first, r_second});
  }

  const std::set<RelationshipCacheWithQueue::CombinationPair>& related_pairs =
      r.RelatedPairs();
  for (const RelationshipCacheWithQueue::CombinationPair& pair :
       related_pairs) {
    if (pair.first == pair.second) {
      std::cout << pair.first << std::endl;
    }
  }

  return 0;
}
